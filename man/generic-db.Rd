% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/backend-.R
\name{sql_translate_env}
\alias{sql_translate_env}
\alias{generic-db}
\alias{db_desc}
\alias{db_list_tables}
\alias{db_has_table}
\alias{db_data_type}
\alias{db_save_query}
\alias{db_begin}
\alias{db_commit}
\alias{db_rollback}
\alias{db_write_table}
\alias{db_create_table}
\alias{db_insert_into}
\alias{db_create_indexes}
\alias{db_create_index}
\alias{db_drop_table}
\alias{db_analyze}
\alias{db_explain}
\alias{db_query_fields}
\alias{db_query_rows}
\title{Database generics.}
\usage{
sql_translate_env(con)

db_desc(x)

db_list_tables(con)

db_has_table(con, table)

db_data_type(con, fields)

db_save_query(con, sql, name, temporary = TRUE, ...)

db_begin(con, ...)

db_commit(con, ...)

db_rollback(con, ...)

db_write_table(con, table, types, values, temporary = FALSE, ...)

db_create_table(con, table, types, temporary = FALSE, ...)

db_insert_into(con, table, values, ...)

db_create_indexes(con, table, indexes = NULL, unique = FALSE, ...)

db_create_index(con, table, columns, name = NULL, unique = FALSE, ...)

db_drop_table(con, table, force = FALSE, ...)

db_analyze(con, table, ...)

db_explain(con, sql, ...)

db_query_fields(con, sql, ...)

db_query_rows(con, sql, ...)
}
\arguments{
\item{con}{A database connection.}

\item{table}{A string, the table name.}

\item{fields}{A list of fields, as in a data frame.}
}
\value{
Usually a logical value indicating success. Most failures should generate
an error. However, \code{db_has_table()} should return \code{NA} if
temporary tables cannot be listed with \code{\link[DBI:dbListTables]{DBI::dbListTables()}} (due to backend
API limitations for example). As a result, your methods will rely on the
backend to throw an error if a table exists when it shouldn't.
}
\description{
The \code{db_} generics execute actions on the database.
}
\details{
There are three families for three main purposes:
\itemize{
\item To to shim over inconsistencies in the implementation of DBI generics.
This includes \code{db_list_tables()}, \code{db_has_table()}, \code{db_begin()},
\code{db_commit()}, \code{db_rollback()}, \code{db_write_table()}, and \code{db_insert_into()}.
These exist mainly for historical reasons as they were written before much
standardisation occurred in the DBI ecosystem. Today, you should avoid
implementing methods for these generics, and instead implement the
underlying DBI S4 method.
\item To perform actions that require SQL generation, and don't have an exiting
DBI generic. This includes the following functions that build and
execute a SQL command
\itemize{
\item \code{db_save_query()}: \verb{CREATE [TEMPORARY] TABLE <table> ...}
\item \code{db_create_index()}: \verb{CREATE INDEX <name> ON <table>}
\item \code{db_drop_table()}: \verb{DROP TABLE [IF EXISTS]  <table>}
\item \code{db_analyze()}: \verb{ANALYZE <table>}
\item \code{db_explain()}: \verb{EXPLAIN <table>}#'
\item \code{db_query_field()}: computes 0-row subset of a query (to determine field types)
\item \code{db_query_rows()}: computes number of rows that will be returned by a query.
}
\item To perform other database actions. This inclues:
\itemize{
\item \code{db_data_type()}: Calls \code{\link[DBI:dbDataType]{DBI::dbDataType()}} for every column in
a data frame field and returns a vector of corresponding SQL data
types
\item \code{db_create_indexes()} calls \code{call_create_index()} for each element
in a named list.
\item \code{sql_translate_env()} which returns \code{\link[=sql_variant]{sql_variant()}}.
}
}

Currently, \code{\link[=copy_to]{copy_to()}} is the only user of \code{db_begin()}, \code{db_commit()},
\code{db_rollback()}, \code{db_write_table()}, \code{db_create_indexes()}, \code{db_drop_table()}
and \code{db_analyze()}. If you find yourself overriding many of these
functions it may suggest that you should just override \code{copy_to()}
instead.

\code{db_create_table()} and \code{db_insert_into()} should not be used in new methods.
Instead call a DBI generic directly.
}
\keyword{internal}
